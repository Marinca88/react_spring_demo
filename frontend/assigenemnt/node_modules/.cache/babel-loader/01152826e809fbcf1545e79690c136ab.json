{"ast":null,"code":"import { BYTE } from './byte';\nimport { FrameImpl } from './frame-impl';\nimport { Parser } from './parser';\nimport { StompSocketState } from './types';\nimport { Versions } from './versions';\nimport { augmentWebsocket } from './augment-websocket';\n/**\n * The STOMP protocol handler\n *\n * Part of `@stomp/stompjs`.\n *\n * @internal\n */\n\nexport class StompHandler {\n  constructor(_client, _webSocket) {\n    let config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this._client = _client;\n    this._webSocket = _webSocket;\n    this._serverFrameHandlers = {\n      // [CONNECTED Frame](http://stomp.github.com/stomp-specification-1.2.html#CONNECTED_Frame)\n      CONNECTED: frame => {\n        this.debug(`connected to server ${frame.headers.server}`);\n        this._connected = true;\n        this._connectedVersion = frame.headers.version; // STOMP version 1.2 needs header values to be escaped\n\n        if (this._connectedVersion === Versions.V1_2) {\n          this._escapeHeaderValues = true;\n        }\n\n        this._setupHeartbeat(frame.headers);\n\n        this.onConnect(frame);\n      },\n      // [MESSAGE Frame](http://stomp.github.com/stomp-specification-1.2.html#MESSAGE)\n      MESSAGE: frame => {\n        // the callback is registered when the client calls\n        // `subscribe()`.\n        // If there is no registered subscription for the received message,\n        // the default `onUnhandledMessage` callback is used that the client can set.\n        // This is useful for subscriptions that are automatically created\n        // on the browser side (e.g. [RabbitMQ's temporary\n        // queues](http://www.rabbitmq.com/stomp.html)).\n        const subscription = frame.headers.subscription;\n        const onReceive = this._subscriptions[subscription] || this.onUnhandledMessage; // bless the frame to be a Message\n\n        const message = frame;\n        const client = this;\n        const messageId = this._connectedVersion === Versions.V1_2 ? message.headers.ack : message.headers['message-id']; // add `ack()` and `nack()` methods directly to the returned frame\n        // so that a simple call to `message.ack()` can acknowledge the message.\n\n        message.ack = function () {\n          let headers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          return client.ack(messageId, subscription, headers);\n        };\n\n        message.nack = function () {\n          let headers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          return client.nack(messageId, subscription, headers);\n        };\n\n        onReceive(message);\n      },\n      // [RECEIPT Frame](http://stomp.github.com/stomp-specification-1.2.html#RECEIPT)\n      RECEIPT: frame => {\n        const callback = this._receiptWatchers[frame.headers['receipt-id']];\n\n        if (callback) {\n          callback(frame); // Server will acknowledge only once, remove the callback\n\n          delete this._receiptWatchers[frame.headers['receipt-id']];\n        } else {\n          this.onUnhandledReceipt(frame);\n        }\n      },\n      // [ERROR Frame](http://stomp.github.com/stomp-specification-1.2.html#ERROR)\n      ERROR: frame => {\n        this.onStompError(frame);\n      }\n    }; // used to index subscribers\n\n    this._counter = 0; // subscription callbacks indexed by subscriber's ID\n\n    this._subscriptions = {}; // receipt-watchers indexed by receipts-ids\n\n    this._receiptWatchers = {};\n    this._partialData = '';\n    this._escapeHeaderValues = false;\n    this._lastServerActivityTS = Date.now();\n    this.configure(config);\n  }\n\n  get connectedVersion() {\n    return this._connectedVersion;\n  }\n\n  get connected() {\n    return this._connected;\n  }\n\n  configure(conf) {\n    // bulk assign all properties to this\n    Object.assign(this, conf);\n  }\n\n  start() {\n    const parser = new Parser( // On Frame\n    rawFrame => {\n      const frame = FrameImpl.fromRawFrame(rawFrame, this._escapeHeaderValues); // if this.logRawCommunication is set, the rawChunk is logged at this._webSocket.onmessage\n\n      if (!this.logRawCommunication) {\n        this.debug(`<<< ${frame}`);\n      }\n\n      const serverFrameHandler = this._serverFrameHandlers[frame.command] || this.onUnhandledFrame;\n      serverFrameHandler(frame);\n    }, // On Incoming Ping\n    () => {\n      this.debug('<<< PONG');\n    });\n\n    this._webSocket.onmessage = evt => {\n      this.debug('Received data');\n      this._lastServerActivityTS = Date.now();\n\n      if (this.logRawCommunication) {\n        const rawChunkAsString = evt.data instanceof ArrayBuffer ? new TextDecoder().decode(evt.data) : evt.data;\n        this.debug(`<<< ${rawChunkAsString}`);\n      }\n\n      parser.parseChunk(evt.data, this.appendMissingNULLonIncoming);\n    };\n\n    this._onclose = closeEvent => {\n      this.debug(`Connection closed to ${this._client.brokerURL}`);\n\n      this._cleanUp();\n\n      this.onWebSocketClose(closeEvent);\n    };\n\n    this._webSocket.onclose = this._onclose;\n\n    this._webSocket.onerror = errorEvent => {\n      this.onWebSocketError(errorEvent);\n    };\n\n    this._webSocket.onopen = () => {\n      // Clone before updating\n      const connectHeaders = Object.assign({}, this.connectHeaders);\n      this.debug('Web Socket Opened...');\n      connectHeaders['accept-version'] = this.stompVersions.supportedVersions();\n      connectHeaders['heart-beat'] = [this.heartbeatOutgoing, this.heartbeatIncoming].join(',');\n\n      this._transmit({\n        command: 'CONNECT',\n        headers: connectHeaders\n      });\n    };\n  }\n\n  _setupHeartbeat(headers) {\n    if (headers.version !== Versions.V1_1 && headers.version !== Versions.V1_2) {\n      return;\n    } // It is valid for the server to not send this header\n    // https://stomp.github.io/stomp-specification-1.2.html#Heart-beating\n\n\n    if (!headers['heart-beat']) {\n      return;\n    } // heart-beat header received from the server looks like:\n    //\n    //     heart-beat: sx, sy\n\n\n    const [serverOutgoing, serverIncoming] = headers['heart-beat'].split(',').map(v => parseInt(v, 10));\n\n    if (this.heartbeatOutgoing !== 0 && serverIncoming !== 0) {\n      const ttl = Math.max(this.heartbeatOutgoing, serverIncoming);\n      this.debug(`send PING every ${ttl}ms`);\n      this._pinger = setInterval(() => {\n        if (this._webSocket.readyState === StompSocketState.OPEN) {\n          this._webSocket.send(BYTE.LF);\n\n          this.debug('>>> PING');\n        }\n      }, ttl);\n    }\n\n    if (this.heartbeatIncoming !== 0 && serverOutgoing !== 0) {\n      const ttl = Math.max(this.heartbeatIncoming, serverOutgoing);\n      this.debug(`check PONG every ${ttl}ms`);\n      this._ponger = setInterval(() => {\n        const delta = Date.now() - this._lastServerActivityTS; // We wait twice the TTL to be flexible on window's setInterval calls\n\n\n        if (delta > ttl * 2) {\n          this.debug(`did not receive server activity for the last ${delta}ms`);\n\n          this._closeOrDiscardWebsocket();\n        }\n      }, ttl);\n    }\n  }\n\n  _closeOrDiscardWebsocket() {\n    if (this.discardWebsocketOnCommFailure) {\n      this.debug('Discarding websocket, the underlying socket may linger for a while');\n\n      this._discardWebsocket();\n    } else {\n      this.debug('Issuing close on the websocket');\n\n      this._closeWebsocket();\n    }\n  }\n\n  forceDisconnect() {\n    if (this._webSocket) {\n      if (this._webSocket.readyState === StompSocketState.CONNECTING || this._webSocket.readyState === StompSocketState.OPEN) {\n        this._closeOrDiscardWebsocket();\n      }\n    }\n  }\n\n  _closeWebsocket() {\n    this._webSocket.onmessage = () => {}; // ignore messages\n\n\n    this._webSocket.close();\n  }\n\n  _discardWebsocket() {\n    if (!this._webSocket.terminate) {\n      augmentWebsocket(this._webSocket, msg => this.debug(msg));\n    }\n\n    this._webSocket.terminate();\n  }\n\n  _transmit(params) {\n    const {\n      command,\n      headers,\n      body,\n      binaryBody,\n      skipContentLengthHeader\n    } = params;\n    const frame = new FrameImpl({\n      command,\n      headers,\n      body,\n      binaryBody,\n      escapeHeaderValues: this._escapeHeaderValues,\n      skipContentLengthHeader\n    });\n    let rawChunk = frame.serialize();\n\n    if (this.logRawCommunication) {\n      this.debug(`>>> ${rawChunk}`);\n    } else {\n      this.debug(`>>> ${frame}`);\n    }\n\n    if (this.forceBinaryWSFrames && typeof rawChunk === 'string') {\n      rawChunk = new TextEncoder().encode(rawChunk);\n    }\n\n    if (typeof rawChunk !== 'string' || !this.splitLargeFrames) {\n      this._webSocket.send(rawChunk);\n    } else {\n      let out = rawChunk;\n\n      while (out.length > 0) {\n        const chunk = out.substring(0, this.maxWebSocketChunkSize);\n        out = out.substring(this.maxWebSocketChunkSize);\n\n        this._webSocket.send(chunk);\n\n        this.debug(`chunk sent = ${chunk.length}, remaining = ${out.length}`);\n      }\n    }\n  }\n\n  dispose() {\n    if (this.connected) {\n      try {\n        // clone before updating\n        const disconnectHeaders = Object.assign({}, this.disconnectHeaders);\n\n        if (!disconnectHeaders.receipt) {\n          disconnectHeaders.receipt = `close-${this._counter++}`;\n        }\n\n        this.watchForReceipt(disconnectHeaders.receipt, frame => {\n          this._closeWebsocket();\n\n          this._cleanUp();\n\n          this.onDisconnect(frame);\n        });\n\n        this._transmit({\n          command: 'DISCONNECT',\n          headers: disconnectHeaders\n        });\n      } catch (error) {\n        this.debug(`Ignoring error during disconnect ${error}`);\n      }\n    } else {\n      if (this._webSocket.readyState === StompSocketState.CONNECTING || this._webSocket.readyState === StompSocketState.OPEN) {\n        this._closeWebsocket();\n      }\n    }\n  }\n\n  _cleanUp() {\n    this._connected = false;\n\n    if (this._pinger) {\n      clearInterval(this._pinger);\n    }\n\n    if (this._ponger) {\n      clearInterval(this._ponger);\n    }\n  }\n\n  publish(params) {\n    const {\n      destination,\n      headers,\n      body,\n      binaryBody,\n      skipContentLengthHeader\n    } = params;\n    const hdrs = Object.assign({\n      destination\n    }, headers);\n\n    this._transmit({\n      command: 'SEND',\n      headers: hdrs,\n      body,\n      binaryBody,\n      skipContentLengthHeader\n    });\n  }\n\n  watchForReceipt(receiptId, callback) {\n    this._receiptWatchers[receiptId] = callback;\n  }\n\n  subscribe(destination, callback) {\n    let headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    headers = Object.assign({}, headers);\n\n    if (!headers.id) {\n      headers.id = `sub-${this._counter++}`;\n    }\n\n    headers.destination = destination;\n    this._subscriptions[headers.id] = callback;\n\n    this._transmit({\n      command: 'SUBSCRIBE',\n      headers\n    });\n\n    const client = this;\n    return {\n      id: headers.id,\n\n      unsubscribe(hdrs) {\n        return client.unsubscribe(headers.id, hdrs);\n      }\n\n    };\n  }\n\n  unsubscribe(id) {\n    let headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    headers = Object.assign({}, headers);\n    delete this._subscriptions[id];\n    headers.id = id;\n\n    this._transmit({\n      command: 'UNSUBSCRIBE',\n      headers\n    });\n  }\n\n  begin(transactionId) {\n    const txId = transactionId || `tx-${this._counter++}`;\n\n    this._transmit({\n      command: 'BEGIN',\n      headers: {\n        transaction: txId\n      }\n    });\n\n    const client = this;\n    return {\n      id: txId,\n\n      commit() {\n        client.commit(txId);\n      },\n\n      abort() {\n        client.abort(txId);\n      }\n\n    };\n  }\n\n  commit(transactionId) {\n    this._transmit({\n      command: 'COMMIT',\n      headers: {\n        transaction: transactionId\n      }\n    });\n  }\n\n  abort(transactionId) {\n    this._transmit({\n      command: 'ABORT',\n      headers: {\n        transaction: transactionId\n      }\n    });\n  }\n\n  ack(messageId, subscriptionId) {\n    let headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    headers = Object.assign({}, headers);\n\n    if (this._connectedVersion === Versions.V1_2) {\n      headers.id = messageId;\n    } else {\n      headers['message-id'] = messageId;\n    }\n\n    headers.subscription = subscriptionId;\n\n    this._transmit({\n      command: 'ACK',\n      headers\n    });\n  }\n\n  nack(messageId, subscriptionId) {\n    let headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    headers = Object.assign({}, headers);\n\n    if (this._connectedVersion === Versions.V1_2) {\n      headers.id = messageId;\n    } else {\n      headers['message-id'] = messageId;\n    }\n\n    headers.subscription = subscriptionId;\n    return this._transmit({\n      command: 'NACK',\n      headers\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["BYTE","FrameImpl","Parser","StompSocketState","Versions","augmentWebsocket","StompHandler","constructor","_client","_webSocket","config","CONNECTED","frame","debug","headers","server","_connected","_connectedVersion","version","V1_2","_escapeHeaderValues","_setupHeartbeat","onConnect","MESSAGE","subscription","onReceive","_subscriptions","onUnhandledMessage","message","client","messageId","ack","nack","RECEIPT","callback","_receiptWatchers","onUnhandledReceipt","ERROR","onStompError","_counter","_partialData","_lastServerActivityTS","Date","now","configure","connectedVersion","connected","conf","Object","assign","start","parser","rawFrame","fromRawFrame","logRawCommunication","serverFrameHandler","_serverFrameHandlers","command","onUnhandledFrame","onmessage","evt","rawChunkAsString","data","ArrayBuffer","TextDecoder","decode","parseChunk","appendMissingNULLonIncoming","_onclose","closeEvent","brokerURL","_cleanUp","onWebSocketClose","onclose","onerror","errorEvent","onWebSocketError","onopen","connectHeaders","stompVersions","supportedVersions","heartbeatOutgoing","heartbeatIncoming","join","_transmit","V1_1","serverOutgoing","serverIncoming","split","map","v","parseInt","ttl","Math","max","_pinger","setInterval","readyState","OPEN","send","LF","_ponger","delta","_closeOrDiscardWebsocket","discardWebsocketOnCommFailure","_discardWebsocket","_closeWebsocket","forceDisconnect","CONNECTING","close","terminate","msg","params","body","binaryBody","skipContentLengthHeader","escapeHeaderValues","rawChunk","serialize","forceBinaryWSFrames","TextEncoder","encode","splitLargeFrames","out","length","chunk","substring","maxWebSocketChunkSize","dispose","disconnectHeaders","receipt","watchForReceipt","onDisconnect","error","clearInterval","publish","destination","hdrs","receiptId","subscribe","id","unsubscribe","begin","transactionId","txId","transaction","commit","abort","subscriptionId"],"sources":["C:\\Users\\Iasmina\\Desktop\\git_demo\\frontend\\assigenemnt2\\node_modules\\@stomp\\stompjs\\src\\stomp-handler.ts"],"sourcesContent":["import { BYTE } from './byte';\nimport { Client } from './client';\nimport { FrameImpl } from './frame-impl';\nimport { IMessage } from './i-message';\nimport { ITransaction } from './i-transaction';\nimport { Parser } from './parser';\nimport { StompConfig } from './stomp-config';\nimport { StompHeaders } from './stomp-headers';\nimport { StompSubscription } from './stomp-subscription';\nimport {\n  closeEventCallbackType,\n  debugFnType,\n  frameCallbackType,\n  IPublishParams,\n  IStompSocket,\n  IStompSocketMessageEvent,\n  messageCallbackType,\n  StompSocketState,\n  wsErrorCallbackType,\n} from './types';\nimport { Versions } from './versions';\nimport { augmentWebsocket } from './augment-websocket';\n\n/**\n * The STOMP protocol handler\n *\n * Part of `@stomp/stompjs`.\n *\n * @internal\n */\nexport class StompHandler {\n  public debug: debugFnType;\n\n  public stompVersions: Versions;\n\n  public connectHeaders: StompHeaders;\n\n  public disconnectHeaders: StompHeaders;\n\n  public heartbeatIncoming: number;\n\n  public heartbeatOutgoing: number;\n\n  public onUnhandledMessage: messageCallbackType;\n\n  public onUnhandledReceipt: frameCallbackType;\n\n  public onUnhandledFrame: frameCallbackType;\n\n  public onConnect: frameCallbackType;\n\n  public onDisconnect: frameCallbackType;\n\n  public onStompError: frameCallbackType;\n\n  public onWebSocketClose: closeEventCallbackType;\n\n  public onWebSocketError: wsErrorCallbackType;\n\n  public logRawCommunication: boolean;\n\n  public splitLargeFrames: boolean;\n\n  public maxWebSocketChunkSize: number;\n\n  public forceBinaryWSFrames: boolean;\n\n  public appendMissingNULLonIncoming: boolean;\n\n  public discardWebsocketOnCommFailure: boolean;\n\n  get connectedVersion(): string {\n    return this._connectedVersion;\n  }\n  private _connectedVersion: string;\n\n  get connected(): boolean {\n    return this._connected;\n  }\n\n  private _connected: boolean;\n\n  private readonly _subscriptions: { [key: string]: messageCallbackType };\n  private readonly _receiptWatchers: { [key: string]: frameCallbackType };\n  private _partialData: string;\n  private _escapeHeaderValues: boolean;\n  private _counter: number;\n  private _pinger: any;\n  private _ponger: any;\n  private _lastServerActivityTS: number;\n\n  private _onclose: (closeEvent: any) => void;\n\n  constructor(\n    private _client: Client,\n    public _webSocket: IStompSocket,\n    config: StompConfig = {}\n  ) {\n    // used to index subscribers\n    this._counter = 0;\n\n    // subscription callbacks indexed by subscriber's ID\n    this._subscriptions = {};\n\n    // receipt-watchers indexed by receipts-ids\n    this._receiptWatchers = {};\n\n    this._partialData = '';\n\n    this._escapeHeaderValues = false;\n\n    this._lastServerActivityTS = Date.now();\n\n    this.configure(config);\n  }\n\n  public configure(conf: StompConfig): void {\n    // bulk assign all properties to this\n    (Object as any).assign(this, conf);\n  }\n\n  public start(): void {\n    const parser = new Parser(\n      // On Frame\n      rawFrame => {\n        const frame = FrameImpl.fromRawFrame(\n          rawFrame,\n          this._escapeHeaderValues\n        );\n\n        // if this.logRawCommunication is set, the rawChunk is logged at this._webSocket.onmessage\n        if (!this.logRawCommunication) {\n          this.debug(`<<< ${frame}`);\n        }\n\n        const serverFrameHandler =\n          this._serverFrameHandlers[frame.command] || this.onUnhandledFrame;\n        serverFrameHandler(frame);\n      },\n      // On Incoming Ping\n      () => {\n        this.debug('<<< PONG');\n      }\n    );\n\n    this._webSocket.onmessage = (evt: IStompSocketMessageEvent) => {\n      this.debug('Received data');\n      this._lastServerActivityTS = Date.now();\n\n      if (this.logRawCommunication) {\n        const rawChunkAsString =\n          evt.data instanceof ArrayBuffer\n            ? new TextDecoder().decode(evt.data)\n            : evt.data;\n        this.debug(`<<< ${rawChunkAsString}`);\n      }\n\n      parser.parseChunk(evt.data, this.appendMissingNULLonIncoming);\n    };\n\n    this._onclose = (closeEvent): void => {\n      this.debug(`Connection closed to ${this._client.brokerURL}`);\n      this._cleanUp();\n      this.onWebSocketClose(closeEvent);\n    };\n\n    this._webSocket.onclose = this._onclose;\n\n    this._webSocket.onerror = (errorEvent): void => {\n      this.onWebSocketError(errorEvent);\n    };\n\n    this._webSocket.onopen = () => {\n      // Clone before updating\n      const connectHeaders = (Object as any).assign({}, this.connectHeaders);\n\n      this.debug('Web Socket Opened...');\n      connectHeaders['accept-version'] = this.stompVersions.supportedVersions();\n      connectHeaders['heart-beat'] = [\n        this.heartbeatOutgoing,\n        this.heartbeatIncoming,\n      ].join(',');\n      this._transmit({ command: 'CONNECT', headers: connectHeaders });\n    };\n  }\n\n  private readonly _serverFrameHandlers: {\n    [key: string]: frameCallbackType;\n  } = {\n    // [CONNECTED Frame](http://stomp.github.com/stomp-specification-1.2.html#CONNECTED_Frame)\n    CONNECTED: frame => {\n      this.debug(`connected to server ${frame.headers.server}`);\n      this._connected = true;\n      this._connectedVersion = frame.headers.version;\n      // STOMP version 1.2 needs header values to be escaped\n      if (this._connectedVersion === Versions.V1_2) {\n        this._escapeHeaderValues = true;\n      }\n\n      this._setupHeartbeat(frame.headers);\n      this.onConnect(frame);\n    },\n\n    // [MESSAGE Frame](http://stomp.github.com/stomp-specification-1.2.html#MESSAGE)\n    MESSAGE: frame => {\n      // the callback is registered when the client calls\n      // `subscribe()`.\n      // If there is no registered subscription for the received message,\n      // the default `onUnhandledMessage` callback is used that the client can set.\n      // This is useful for subscriptions that are automatically created\n      // on the browser side (e.g. [RabbitMQ's temporary\n      // queues](http://www.rabbitmq.com/stomp.html)).\n      const subscription = frame.headers.subscription;\n      const onReceive =\n        this._subscriptions[subscription] || this.onUnhandledMessage;\n\n      // bless the frame to be a Message\n      const message = frame as IMessage;\n\n      const client = this;\n      const messageId =\n        this._connectedVersion === Versions.V1_2\n          ? message.headers.ack\n          : message.headers['message-id'];\n\n      // add `ack()` and `nack()` methods directly to the returned frame\n      // so that a simple call to `message.ack()` can acknowledge the message.\n      message.ack = (headers: StompHeaders = {}): void => {\n        return client.ack(messageId, subscription, headers);\n      };\n      message.nack = (headers: StompHeaders = {}): void => {\n        return client.nack(messageId, subscription, headers);\n      };\n      onReceive(message);\n    },\n\n    // [RECEIPT Frame](http://stomp.github.com/stomp-specification-1.2.html#RECEIPT)\n    RECEIPT: frame => {\n      const callback = this._receiptWatchers[frame.headers['receipt-id']];\n      if (callback) {\n        callback(frame);\n        // Server will acknowledge only once, remove the callback\n        delete this._receiptWatchers[frame.headers['receipt-id']];\n      } else {\n        this.onUnhandledReceipt(frame);\n      }\n    },\n\n    // [ERROR Frame](http://stomp.github.com/stomp-specification-1.2.html#ERROR)\n    ERROR: frame => {\n      this.onStompError(frame);\n    },\n  };\n\n  private _setupHeartbeat(headers: StompHeaders): void {\n    if (\n      headers.version !== Versions.V1_1 &&\n      headers.version !== Versions.V1_2\n    ) {\n      return;\n    }\n\n    // It is valid for the server to not send this header\n    // https://stomp.github.io/stomp-specification-1.2.html#Heart-beating\n    if (!headers['heart-beat']) {\n      return;\n    }\n\n    // heart-beat header received from the server looks like:\n    //\n    //     heart-beat: sx, sy\n    const [serverOutgoing, serverIncoming] = headers['heart-beat']\n      .split(',')\n      .map((v: string) => parseInt(v, 10));\n\n    if (this.heartbeatOutgoing !== 0 && serverIncoming !== 0) {\n      const ttl: number = Math.max(this.heartbeatOutgoing, serverIncoming);\n      this.debug(`send PING every ${ttl}ms`);\n      this._pinger = setInterval(() => {\n        if (this._webSocket.readyState === StompSocketState.OPEN) {\n          this._webSocket.send(BYTE.LF);\n          this.debug('>>> PING');\n        }\n      }, ttl);\n    }\n\n    if (this.heartbeatIncoming !== 0 && serverOutgoing !== 0) {\n      const ttl: number = Math.max(this.heartbeatIncoming, serverOutgoing);\n      this.debug(`check PONG every ${ttl}ms`);\n      this._ponger = setInterval(() => {\n        const delta = Date.now() - this._lastServerActivityTS;\n        // We wait twice the TTL to be flexible on window's setInterval calls\n        if (delta > ttl * 2) {\n          this.debug(`did not receive server activity for the last ${delta}ms`);\n          this._closeOrDiscardWebsocket();\n        }\n      }, ttl);\n    }\n  }\n\n  private _closeOrDiscardWebsocket() {\n    if (this.discardWebsocketOnCommFailure) {\n      this.debug(\n        'Discarding websocket, the underlying socket may linger for a while'\n      );\n      this._discardWebsocket();\n    } else {\n      this.debug('Issuing close on the websocket');\n      this._closeWebsocket();\n    }\n  }\n\n  public forceDisconnect() {\n    if (this._webSocket) {\n      if (\n        this._webSocket.readyState === StompSocketState.CONNECTING ||\n        this._webSocket.readyState === StompSocketState.OPEN\n      ) {\n        this._closeOrDiscardWebsocket();\n      }\n    }\n  }\n\n  public _closeWebsocket() {\n    this._webSocket.onmessage = () => {}; // ignore messages\n    this._webSocket.close();\n  }\n\n  private _discardWebsocket() {\n    if (!this._webSocket.terminate) {\n      augmentWebsocket(this._webSocket, (msg: string) => this.debug(msg));\n    }\n\n    this._webSocket.terminate();\n  }\n\n  private _transmit(params: {\n    command: string;\n    headers?: StompHeaders;\n    body?: string;\n    binaryBody?: Uint8Array;\n    skipContentLengthHeader?: boolean;\n  }): void {\n    const { command, headers, body, binaryBody, skipContentLengthHeader } =\n      params;\n    const frame = new FrameImpl({\n      command,\n      headers,\n      body,\n      binaryBody,\n      escapeHeaderValues: this._escapeHeaderValues,\n      skipContentLengthHeader,\n    });\n\n    let rawChunk = frame.serialize();\n\n    if (this.logRawCommunication) {\n      this.debug(`>>> ${rawChunk}`);\n    } else {\n      this.debug(`>>> ${frame}`);\n    }\n\n    if (this.forceBinaryWSFrames && typeof rawChunk === 'string') {\n      rawChunk = new TextEncoder().encode(rawChunk);\n    }\n\n    if (typeof rawChunk !== 'string' || !this.splitLargeFrames) {\n      this._webSocket.send(rawChunk);\n    } else {\n      let out = rawChunk as string;\n      while (out.length > 0) {\n        const chunk = out.substring(0, this.maxWebSocketChunkSize);\n        out = out.substring(this.maxWebSocketChunkSize);\n        this._webSocket.send(chunk);\n        this.debug(`chunk sent = ${chunk.length}, remaining = ${out.length}`);\n      }\n    }\n  }\n\n  public dispose(): void {\n    if (this.connected) {\n      try {\n        // clone before updating\n        const disconnectHeaders = (Object as any).assign(\n          {},\n          this.disconnectHeaders\n        );\n\n        if (!disconnectHeaders.receipt) {\n          disconnectHeaders.receipt = `close-${this._counter++}`;\n        }\n        this.watchForReceipt(disconnectHeaders.receipt, frame => {\n          this._closeWebsocket();\n          this._cleanUp();\n          this.onDisconnect(frame);\n        });\n        this._transmit({ command: 'DISCONNECT', headers: disconnectHeaders });\n      } catch (error) {\n        this.debug(`Ignoring error during disconnect ${error}`);\n      }\n    } else {\n      if (\n        this._webSocket.readyState === StompSocketState.CONNECTING ||\n        this._webSocket.readyState === StompSocketState.OPEN\n      ) {\n        this._closeWebsocket();\n      }\n    }\n  }\n\n  private _cleanUp() {\n    this._connected = false;\n\n    if (this._pinger) {\n      clearInterval(this._pinger);\n    }\n    if (this._ponger) {\n      clearInterval(this._ponger);\n    }\n  }\n\n  public publish(params: IPublishParams): void {\n    const { destination, headers, body, binaryBody, skipContentLengthHeader } =\n      params;\n    const hdrs: StompHeaders = (Object as any).assign({ destination }, headers);\n    this._transmit({\n      command: 'SEND',\n      headers: hdrs,\n      body,\n      binaryBody,\n      skipContentLengthHeader,\n    });\n  }\n\n  public watchForReceipt(receiptId: string, callback: frameCallbackType): void {\n    this._receiptWatchers[receiptId] = callback;\n  }\n\n  public subscribe(\n    destination: string,\n    callback: messageCallbackType,\n    headers: StompHeaders = {}\n  ): StompSubscription {\n    headers = (Object as any).assign({}, headers);\n\n    if (!headers.id) {\n      headers.id = `sub-${this._counter++}`;\n    }\n    headers.destination = destination;\n    this._subscriptions[headers.id] = callback;\n    this._transmit({ command: 'SUBSCRIBE', headers });\n    const client = this;\n    return {\n      id: headers.id,\n\n      unsubscribe(hdrs) {\n        return client.unsubscribe(headers.id, hdrs);\n      },\n    };\n  }\n\n  public unsubscribe(id: string, headers: StompHeaders = {}): void {\n    headers = (Object as any).assign({}, headers);\n\n    delete this._subscriptions[id];\n    headers.id = id;\n    this._transmit({ command: 'UNSUBSCRIBE', headers });\n  }\n\n  public begin(transactionId: string): ITransaction {\n    const txId = transactionId || `tx-${this._counter++}`;\n    this._transmit({\n      command: 'BEGIN',\n      headers: {\n        transaction: txId,\n      },\n    });\n    const client = this;\n    return {\n      id: txId,\n      commit(): void {\n        client.commit(txId);\n      },\n      abort(): void {\n        client.abort(txId);\n      },\n    };\n  }\n\n  public commit(transactionId: string): void {\n    this._transmit({\n      command: 'COMMIT',\n      headers: {\n        transaction: transactionId,\n      },\n    });\n  }\n\n  public abort(transactionId: string): void {\n    this._transmit({\n      command: 'ABORT',\n      headers: {\n        transaction: transactionId,\n      },\n    });\n  }\n\n  public ack(\n    messageId: string,\n    subscriptionId: string,\n    headers: StompHeaders = {}\n  ): void {\n    headers = (Object as any).assign({}, headers);\n\n    if (this._connectedVersion === Versions.V1_2) {\n      headers.id = messageId;\n    } else {\n      headers['message-id'] = messageId;\n    }\n    headers.subscription = subscriptionId;\n    this._transmit({ command: 'ACK', headers });\n  }\n\n  public nack(\n    messageId: string,\n    subscriptionId: string,\n    headers: StompHeaders = {}\n  ): void {\n    headers = (Object as any).assign({}, headers);\n\n    if (this._connectedVersion === Versions.V1_2) {\n      headers.id = messageId;\n    } else {\n      headers['message-id'] = messageId;\n    }\n    headers.subscription = subscriptionId;\n    return this._transmit({ command: 'NACK', headers });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}